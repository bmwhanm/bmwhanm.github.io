<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="bsdy">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="bsdy">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="bsdy">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Penulis'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>bsdy</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">bsdy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Beranda
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Arsip
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/29/结合Path和Canvas，属性动画的自定义View/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/29/结合Path和Canvas，属性动画的自定义View/" itemprop="url">结合Path和Canvas，属性动画的自定义View</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Diposting di</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-29T16:55:20+08:00">
                2017-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/29/ipc的基础用法二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/29/ipc的基础用法二/" itemprop="url">ipc的基础用法二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Diposting di</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-29T16:52:03+08:00">
                2017-06-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="IPC的基础用法"><a href="#IPC的基础用法" class="headerlink" title="IPC的基础用法"></a>IPC的基础用法</h4><pre><code>这篇文章继续介绍AIDL，然后小结一下关于Binder的知识点。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/24/IPC用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/24/IPC用法/" itemprop="url">IPC用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Diposting di</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-24T00:51:34+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="IPC的用法的学习"><a href="#IPC的用法的学习" class="headerlink" title="IPC的用法的学习"></a>IPC的用法的学习</h4><pre><code>    这篇文章来小结一下自己学的IPC的知识，包括Messenger和AIDL，然后我在总结一
下自己最近学的关于Binder的知识。

    在了解IPC前先说明一下什么是进程什么是线程，按照操作系统中的描述，线程是CPU
 调度的最小单元，同时线程是一种有限的系统资源，而进程一般指一个执行单元，在
 android指一个应用。一个进程可以包含多个线程，因此进程和线程是包含与被包含的关
 系，在最简单的情况下，一个进程中可以只有一个线程即主线程，在android中主线程也
 叫UI线程，在UI线程里面才能操作界面元素。IPC(进程间通信)是主要用于两个进程，有
 时候我们需要在应用间（即两个进程间）交换数据，这时候就需要IPC。实现进程间通信有
 很多方式，我这里就只介绍Messenger和AIDL，至于其它的方式我就不介绍了。
</code></pre><h5 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h5><pre><code>   Messenger就是对Binder做了一个简单的封装，我们在做一些简单的跨进程通信的时
候可以使用Messenger，比AILDL简单。首先看一下构造方法

   Messenger(Handler target);//用一个Handler创造一个Messenger实例，当有
一个新的Message发送到这个Messenger的时候，这个Messenger就回调用它的
handler.sendMessage(),这个时候这个Message就会被这个Handler所处理。里面具
体的怎么跨进程的就留到总结Binder的时候再细说，这里就需要理解到这个时候就会调用
远程进程的那个Handler。

   Messenger(IBinder target);//用一个IBinder对象来构建一个Messenger实
例，这个Messnegr就会关联到这个IBinder对象的Handler，向这个Messenger发送
Message的时候就会让对应的Handler来处理，这个主要用来在客户端构造服务端的
Messenger对象时调用。

下面来个简单的例子：
</code></pre><p>上代码：</p>
<pre><code>//服务端
public class MessengerService extends Service {
    public static final int  SAY_HELLO =1;
    class MessengerHandler  extends Handler{
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            switch (msg.what){
                case SAY_HELLO:
                    Bundle data = msg.getData();
                    String str = data.getString(&quot;data&quot;);
                    Log.e(&quot;TAG&quot;,&quot;MessengerService Received say_hello: &quot;+str);

                    break;
            }
        }
    }
    private Messenger mMessenger = new Messenger(new MessengerHandler());

    @Override
    public IBinder onBind(Intent intent) {
        // TODO: Return the communication channel to the service.
        return mMessenger.getBinder();
    }

}
//客户端
 private ServiceConnection mConn = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        mMessenger = new Messenger(service);
        Message msg = Message.obtain(null,MessengerService.SAY_HELLO);
        Bundle data = new Bundle();
        data.putString(&quot;data&quot;,&quot;Hello from Client&quot;);
        msg.setData(data);
        try {
            mMessenger.send(msg);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        mBond = true;
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
        mBond = false;
    }
};
看一下服务端的打印
</code></pre><p><img src="../img/ipc_1.png" alt=""></p>
<pre><code>上面只是客户端向服务端传递数据，那么服务端向客户端传递数据的原理是一样的，首先需
要创建一个客户端的Messenger的实例，然后丢给发送到服务端的Message的replyTo字
段，服务端去的这个字端就是拿到了客户端的Messenger，就可以向客户端发送数据了。下
面看一下更改后的代码：


//客户端
class ClientHandler extends Handler{
    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what){
            case 1:
                Bundle data = msg.getData();
                String str = data.getString(&quot;data&quot;);
                Log.e(&quot;TAG&quot;,&quot;客户端已经收到服务端的信息&quot;+str);
            break;
        }
    }
}
private Messenger mClient = new Messenger(new ClientHandler());
private ServiceConnection mConn = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        mMessenger = new Messenger(service);
        Message msg = Message.obtain(null,MessengerService.SAY_HELLO);
        Bundle data = new Bundle();
        data.putString(&quot;data&quot;,&quot;Hello from Client&quot;);
        msg.setData(data);
        msg.replyTo = mClient;
        try {
            mMessenger.send(msg);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
        mBond = true;
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
        mBond = false;
    }
};
//服务端的代码
public class MessengerService extends Service {
public static final int  SAY_HELLO =1;
class MessengerHandler  extends Handler{
    @Override
    public void handleMessage(Message msg) {
        super.handleMessage(msg);
        switch (msg.what){
            case SAY_HELLO:
                Bundle data = msg.getData();
                String str = data.getString(&quot;data&quot;);
                Log.e(&quot;TAG&quot;,&quot;MessengerService Received say_hello: &quot;+str);

                Messenger mClient = msg.replyTo;
                Message mMsgClient = new Message();
                mMsgClient.what = 1;
                Bundle bun = new Bundle();
                bun.putString(&quot;data&quot;,&quot;服务端已经收到你的消息，稍后会回复你的....&quot;);
                mMsgClient.setData(bun);
                try {
                    mClient.send(mMsgClient);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
                break;
        }
    }
}
private Messenger mMessenger = new Messenger(new MessengerHandler());

@Override
public IBinder onBind(Intent intent) {
    // TODO: Return the communication channel to the service.
    return mMessenger.getBinder();
}

}
</code></pre><p><img src="../img/ipc_2.png" alt=""></p>
<h5 id="AIDL（Android-接口定义语言）"><a href="#AIDL（Android-接口定义语言）" class="headerlink" title="AIDL（Android 接口定义语言）"></a>AIDL（Android 接口定义语言）</h5><ul>
<li><p>定义 AIDL 接口</p>
<pre><code>当每次新建一个aidl文件时，Android SDK 工具都会生成一个基于该 .aidl 文件的 IBinder 接口，并将其保存在项目的 gen/ 目录中。服务必须视情况实现 IBinder 接口。然后客户端应用便可绑定到该服务，并调用 IBinder 中的方法来执行 IPC。一般创建一个aidl服务执行下面的步骤：
1.创建 .aidl 文件
2.实现接口
    Android SDK 工具基于您的 .aidl 文件，使用 Java 编程语言生成一个接
    口。此接口具有一个名为 Stub 的内部抽象类，用于扩展 Binder 类并实现 
    AIDL 接口中的方法。您必须扩展 Stub 类并实现方法。
3.向客户端公开该接口
    实现 Service 并重写 onBind() 以返回 Stub 类的实现。
</code></pre></li>
</ul>
<p>上代码：</p>
<pre><code>//新建AIDL文件
// First.aidl
package com.hq.demo.aidltest;

// Declare any non-default types here with import statements

interface First {
    /**
     * Demonstrates some basic types that you can use as parameters
     * and return values in AIDL.
     */
    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,
            double aDouble, String aString);

    String getStringFromClient(in String str);
}

//服务端的代码，实现其Stub类
public class FirstAidlService extends Service {
private FirstBinder mBinder;
@Override
public void onCreate() {
    super.onCreate();
    mBinder = new FirstBinder();
}

public FirstAidlService() {
}

@Override
public IBinder onBind(Intent intent) {
    // TODO: Return the communication channel to the service.
    return mBinder;
}


class FirstBinder extends First.Stub{

    @Override
    public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException {

    }

    @Override
    public String getStringFromClient(String str) throws RemoteException {
        return &quot;String from Server    &quot;+str ;
    }
}
}

 //客户端绑定服务时需要的ServiceConnection
 private ServiceConnection mConn = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        mBinder = First.Stub.asInterface(service);//获得服务端的Binder对象，并将其转换成为First类，此时客户端就可以调用服务端的代码了，实现跨进程访问
        mBond = true;
        try {
            String str = mBinder.getStringFromClient(&quot;Client to Server&quot;);
            Log.e(&quot;TAG&quot;,&quot;Client : &quot;+str);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
        mBond = false;
    }
};
</code></pre><p>看下日志：<br><img src="../img/ipc_aidl_4.png" alt=""></p>
<pre><code>客户端和服务端实现了跨进程调用，这是最简单的跨进程调用，我们客户端只是向服务端传递了一个字符串，并且服务端返回了一个字符串，下面就了解一下AIDL跨进程调用能够传递哪些数据。
</code></pre><ul>
<li><p>通过 IPC 传递对象</p>
<pre><code>默认情况下，AIDL 支持下列数据类型：
Java 编程语言中的所有原语类型（如 int、long、char、boolean 等等），
String
CharSequence

List
List 中的所有元素都必须是以上列表中支持的数据类型、其他 AIDL 生成的接口或
您声明的可打包类型。 可选择将 List 用作“通用”类（例如，List&lt;String&gt;）。
另一端实际接收的具体类始终是 ArrayList，但生成的方法使用的是 List 接口。

Map
Map 中的所有元素都必须是以上列表中支持的数据类型、其他 AIDL 生成的接口或您
声明的可打包类型。 不支持通用 Map（如 Map&lt;String,Integer&gt; 形式的 
Map）。 另一端实际接收的具体类始终是 HashMap，但生成的方法使用的是 Map 接
口。

上面是基本的类型，通过 IPC 接口把某个类从一个进程发送到另一个进程是可以实现的。 不过，您必须确保该类的代码对 IPC 通道的另一端可用，并且该类必须支持 Parcelable 接口。因为是跨进程这个对象在两个进程中的包名都必须是一样的，因为在不同的进程，就是不同的对象，程序需要把另一个进程传递过来的对象，实例化为本进程的可识别的对象。把需要传递的对象实现Parcelable接口，并且要定义成.aidl接口的形式，
在写aidl文件的时候必须为每个附加类型加入一个import语句，即使这些类型与你定义的aidl的接口在同一个包中。还有一点就是在写aidl方法时，如果方法的参数类型时非源语，那么就必须要加上指示数据走向的方向标记，可以是in，out，inout，原语默认是in，不能是其它方向，

注意：您应该将方向限定为真正需要的方向，因为编组参数的开销极大。
</code></pre></li>
</ul>
<p>上代码：</p>
<pre><code>// First.aidl
package com.hq.demo.aidltest;
import com.hq.demo.aidltest.Book;    
interface First {
    /**
     * Demonstrates some basic types that you can use as parameters
     * and return values in AIDL.
     */
    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,
            double aDouble, String aString);

    String getStringFromClient(String str);
    Book addBook(in Book book);
    List&lt;Book&gt; getBookList();
}

//服务端
public class FirstAidlService extends Service {
    private FirstBinder mBinder;
    //因为通过Binder类调用服务端的方法，改方法会执行在Binder线程池里面，不是
    //主线程，所以需要关注线程间的同步问题。而CopyOnWriteArrayList已经帮我
    //们实现了线程同步的问题。
    private CopyOnWriteArrayList&lt;Book&gt; mData;

    @Override
    public void onCreate() {
        super.onCreate();

        mData = new CopyOnWriteArrayList&lt;&gt;();
        Book b1 = new Book();
        b1.setmBookName(&quot;book1&quot;);
        b1.setmPrice(1.0f);
        Book b2 = new Book();
        b2.setmBookName(&quot;book2&quot;);
        b2.setmPrice(2.0f);
        mData.add(b1);
        mData.add(b2);
        mBinder = new FirstBinder();
    }

    public FirstAidlService() {
    }

    @Override
    public IBinder onBind(Intent intent) {
        // TODO: Return the communication channel to the service.
        return mBinder;
    }

    //实现First.Stub 接口，实现里面的方法，在onBind()里面返回相应的Binder类，
    class FirstBinder extends First.Stub{
        @Override
        public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException {

        }

        @Override
        public String getStringFromClient(String str) throws RemoteException {
            return &quot;String from Server    &quot;+str ;
        }

        @Override
        public Book addBook(Book book){
            Book book1 = new Book();
            Log.e(&quot;TAG&quot;,&quot;Server addBook from Client Book:&quot;+book);
            book1.setmBookName(&quot;ServerBookName&quot;);
            book1.setmPrice(10.2f);
            mData.add(book);
            return book1;
        }

        @Override
        public List&lt;Book&gt; getBookList() throws RemoteException {
            return mData;
        }

    }

}
// 客户端代码
private ServiceConnection mConn = new ServiceConnection() {
    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        mBinder = First.Stub.asInterface(service);//获得服务端的Binder接口
        mBond = true;
        try {
            String str = mBinder.getStringFromClient(&quot;Client to Server&quot;);
            Log.e(&quot;TAG&quot;,&quot;Client : &quot;+str);
            Book b = new Book();
            b.setmBookName(&quot;Client Book&quot;);
            b.setmPrice(9.1f);
            //通过Binder调用服务端的方法
            Book book = mBinder.addBook(b);
            Log.e(&quot;TAG&quot;, &quot;AIDL Base addBook(): &quot; + book);

            List&lt;Book&gt; books  = mBinder.getBookList();
            Log.e(&quot;TAG&quot;,books.toString());
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {
        mBond = false;
    }
}
</code></pre><p><img src="../img/ipc_aidl_5.png" alt=""></p>
<pre><code>接下来，简单介绍两个很重要的方法，linkToDeath()和unlinkToDeath();我们知道，Binder运行在服务端的进程中，如果服务端进程由于某种原因异常终止，这个时候如果我们还在调用服务端的方法，这就会导致调用失败，这个时候急需要用到linkToDeath();当Binder死亡的时候我们就会收到相应的通知。
</code></pre><p>上代码：</p>
<pre><code> private IBinder.DeathRecipient mRecipient = new IBinder.DeathRecipient() {
    @Override
    public void binderDied() {
        Log.e(&quot;TAG&quot;,&quot;mRecipient binderDied&quot;);
        if(mBinder == null)
            return;
        mBinder.asBinder().unlinkToDeath(mRecipient,0);
        mBinder = null;
       //下面可以做重新绑定的操作
    }
};


 @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        mBinder = First.Stub.asInterface(service);
        mBond = true;
        try {
        ........
            service.linkToDeath(mRecipient,0);
        } catch (RemoteException e) {
            e.printStackTrace();
        }
    }
       上面就实现了当服务端的进程异常终止时，所要回调的方法，并且可以执行重新
   绑定服务的操作。
</code></pre><p>  这篇文章就到这吧，太长了，接下来还会继续介绍AIDL和Binder相关的知识点。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/24/Service的用法详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/24/Service的用法详解/" itemprop="url">Service的用法详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Diposting di</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-24T00:49:43+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Service的用法详解"><a href="#Service的用法详解" class="headerlink" title="Service的用法详解"></a>Service的用法详解</h4><pre><code>   学习androidService一直都没总结过，这次来好好的总结一下，一个系列，希望能
够把IPC和Service能够总结清楚。Service 是一个可以在后台执行长时间运行操作而不
提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服
务仍将在后台继续运行。 此外，组件可以绑定到服务，以与之进行交互，甚至是执行进程
间通信 (IPC)。 例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提
供程序交互，而所有这一切均可在后台进行。
   Service是android的四大组件之一，跟Activity一样，来看一下启动服务，绑定服务下的生命周期。
</code></pre><h5 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h5><pre><code>当应用组件（如 Activity）通过调用 startService() 启动服务时，服务即处于“启动”状态。一旦启动，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。 已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如，它可能通过网络下载或上传文件。 操作完成后，服务会自行停止运行。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/19/根据Shader的自定义View/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/19/根据Shader的自定义View/" itemprop="url">根据Shader的自定义View和放大镜</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Diposting di</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-19T16:07:46+08:00">
                2017-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="根据Shader的自定义View和放大镜"><a href="#根据Shader的自定义View和放大镜" class="headerlink" title="根据Shader的自定义View和放大镜"></a>根据Shader的自定义View和放大镜</h4><pre><code>    前期学习了很多关于Paint的基础用法，重要用来做点什么，否则的话很快就会忘记
的，这篇文章就先来实现个简单的Shader的用法，下面还会再来一篇。
    当我们在学习Shader的时候就看到了他的定义，Shader是用来在绘制的过程中把相应
的颜色绘制出来，比如说一张图片有很多的像素值，那么在用这个设置了BitmapShader的
Paint对象绘制任何图形的时候都会在相应的位置绘制出相应的像素。好了，我们理解了这
一点那么接下来的工作就比较简单了。
    先看效果
</code></pre><p><img src="../img/paint_4_shaderView_1.gif" alt=""></p>
<pre><code>    下面就看看该如何实现上面的效果，首先肯定是一张白色的背景图，然后监听我们手指
的出触摸的位置，然后在相应的位置画个圆出来，那么问题就在于如何把这个图片相应的像
素值设置给画笔，这时候就会用到我们的BitmapShader.

public class PaintShaderView extends View {
private Paint mPaint;
private Bitmap mBitmap;
private float dx,dy;
public PaintShaderView(Context context) {
    this(context,null);
}

public PaintShaderView(Context context, AttributeSet attrs) {
    this(context, attrs,0);
}

public PaintShaderView(Context context, AttributeSet attrs, int defStyleAttr) {
mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.girl);
initPaint();
}

 private void initPaint() {
    mPaint = new Paint();
    mPaint.setAntiAlias(true);
    mPaint.setDither(true);
    mPaint.setStrokeWidth(5);
}
  @Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.drawColor(Color.WHITE);
    BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT);
     mPaint.setShader(shader);
     if(dx != 0 &amp;&amp; dy != 0)
    canvas.drawCircle(dx,dy,150,mPaint);
}
@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()){
        case MotionEvent.ACTION_DOWN:
            dx = 0;
            dy = 0;
            invalidate();
            return  true;
        case MotionEvent.ACTION_MOVE:
            dx = event.getX();
            dy = event.getY();
            invalidate();
            return true;
        case MotionEvent.ACTION_UP:
            dx = 0;
            dy = 0;
            break;
    }
    invalidate();
    return super.onTouchEvent(event);
}
}
</code></pre><h5 id="根据Shader制作放大器自定义View"><a href="#根据Shader制作放大器自定义View" class="headerlink" title="根据Shader制作放大器自定义View"></a>根据Shader制作放大器自定义View</h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/Paint的Gradient的用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/Paint的Gradient的用法/" itemprop="url">Paint的Gradient的用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Diposting di</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-15T13:53:17+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Paint的Gradient的用法"><a href="#Paint的Gradient的用法" class="headerlink" title="Paint的Gradient的用法"></a>Paint的Gradient的用法</h4><h5 id="shader的基本介绍"><a href="#shader的基本介绍" class="headerlink" title="shader的基本介绍"></a>shader的基本介绍</h5><pre><code>shader是一个在绘制的过程中能够水平的平分颜色的一个基类，通过Shader的子类的实现
来给Paint设置Shader，设置过之后，绘制任何对象时都会带着这个Shader的颜色。
</code></pre><h5 id="BitmapShader"><a href="#BitmapShader" class="headerlink" title="BitmapShader"></a>BitmapShader</h5><pre><code>这是一个非常有用的类，下面我会介绍一些这个类的基本的用法，中间会包括一些
Shader的基本用法，都在这个介绍类的里面了，下面可 is hi，我们首先看看这个类的
构造函数，然后直接使用，看看会有什么奇妙的东西发生。这个Shader作为纹理被用来
绘制Bitmap看看构造方法.
</code></pre><ul>
<li><p>REPEAT</p>
<pre><code>mRect = new RectF(0,0,200,200);
mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.girl);
BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT);
mPaint.setShader(shader);
canvas.drawRect(0,0,getWidth(),getHeight() ,mPaint);
</code></pre><p><img src="/img/paint_3_shader_1.png" alt=""><br><br></p>
<pre><code>根据图片，我们看到绘制出来的不是单独的的一张照片，而是单张照片的重复，这就
涉及到在上面的代码中，我们没有提到的Shader.TileMode这个内部类。这个类内
部有三个值，分别是CLAMP，REPEAT，MIRROR。其中CLAMP代表的是重复绘制这个
Shader的边缘的像素，当超出这个Shader的原始界限的时候，REPEAT就是重复，
MIRROR就是镜像。这个三个值的不用多说，看看代码的效果就明白了。
</code></pre><p>上代码：</p>
</li>
<li><p>CLAMP</p>
<pre><code>mRect = new RectF(0,0,200,200);
mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.girl);
BitmapShader shader = new BitmapShader(mBitmap,Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
mPaint.setShader(shader);
canvas.drawRect(0,0,getWidth(),getHeight() ,mPaint);
</code></pre></li>
</ul>
<p><img src="/img/paint_3_shader_2.png" alt="这是CLAMP的效果"></p>
<ul>
<li><p>MIRROR</p>
<pre><code>mRect = new RectF(0,0,200,200);
mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.girl);
BitmapShader shader = new BitmapShader(mBitmap,Shader.TileMode. MIRROR, Shader.TileMode. MIRROR);
mPaint.setShader(shader);
canvas.drawRect(0,0,getWidth(),getHeight() ,mPaint);
</code></pre></li>
</ul>
<p><img src="/img/paint_3_shader_3.png" alt="这是CLAMP的效果"></p>
<pre><code>解释一下构造方法：
BitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY)
bitmap：就是你给这个BitmapShader设置的图片
tileX：就是当这个Shader超出这个图像的原始的边界的时候，给这个Shader设置的X轴方向的拉伸规则
tileY：同理上面的tileX
</code></pre><p><br></p>
<h5 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h5><pre><code>下面再来一个比较有点意思的类，Matrix，矩阵。Matrix是一个为了转换坐标持有一个
3*3的矩阵的一个类。因为这里是在Shader的知识里面，我们就介绍一点基本知识就行，
Matrix的构造方法没什么要看的，大家一看就明白，分别是Matrix()，Matrix(Matrix src)
然后看看他的setScale(float sx, float sy)方法，sx，sy分别表示X，Y轴的缩放比例。
我们在Shader的setLocalMatrix (Matrix localM)里面会用到矩阵的变换，那么
</code></pre><p>上代码：</p>
<pre><code>BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR);
Matrix matrix = new Matrix();
matrix.setScale(1.5f,0.5f);
shader.setLocalMatrix(matrix);
mPaint.setShader(shader);        
canvas.drawRect(0,0,getWidth(),getHeight() ,mPaint);
</code></pre><p><img src="/img/paint_3_shader_4.png" alt=""></p>
<pre><code>从上面的图可以看出，X轴放大了1.5倍，Y轴缩小了0.5倍

下面我们接着看看Matrix的其它方法setTranslate(float dx, float dy)，设置    矩阵沿着X，Y轴分别平移dx，dy。dx为正，图片就右移，反之左移，dy为正图片下移，
反之上移
</code></pre><p>上代码：</p>
<pre><code>BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR);
Matrix matrix = new Matrix();
matrix.setTranslate(50,50);
shader.setLocalMatrix(matrix);
mPaint.setShader(shader);        
canvas.drawRect(0,0,getWidth(),getHeight() ,mPaint);
</code></pre><p><img src="/img/paint_3_shader_5.png" alt=""></p>
<pre><code>setRotate(float degrees),设置矩阵围绕着原点旋转degrees度。
setSkew(float kx, float ky)，设置矩阵的X，Y方向的倾斜度。
这两个方法，我就不运行了，大家自己试一下。
好了，到这里我就把BitmapShader介绍的差不多了，也介绍了Shader的setLocalMatrix(matrix)方法
顺便说了一点Matrix类，下面回归主题，看看其它的Shader的子类。
</code></pre><h5 id="LinearGradient"><a href="#LinearGradient" class="headerlink" title="LinearGradient"></a>LinearGradient</h5><pre><code>线性渐变，比较简单，把构造方法弄明白就行了
LinearGradient(float x0, float y0, float x1, float y1, int[] colors, float[] positions, Shader.TileMode tile)
x0,y0,x1,y1 : 代表这个颜色变化的起点位置和终点位置
colors: 是颜色的变化的范围
positions ：是每个颜色的在总变化的范围所占的所有的值加起来等于1 。类似于权重,可以为null，为null的话就是每个颜色所占的比重相同
tile：是这个图形的拉伸规则，参看BitmapShader
</code></pre><p>上代码：</p>
<pre><code>LinearGradient gradient = new LinearGradient(0,200,200,200,new int[]{Color.RED,Color.YELLOW,Color.GREEN},null, Shader.TileMode.CLAMP);
mPaint.setShader(gradient);
canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);
</code></pre><p><img src="/img/paint_3_shader_6.png" alt=""></p>
<h5 id="RadialGradient"><a href="#RadialGradient" class="headerlink" title="RadialGradient"></a>RadialGradient</h5><pre><code>径向渐变，直接看
RadialGradient(float centerX, float centerY, float radius, int[] colors, float[] stops, Shader.TileMode tileMode)
centerX，centerY，radius，是画圆的三个要素，中心坐标加半径。
colors：是颜色的变化范围
stops：这个数组里面的数对应的是颜色的变化范围到什么位置停止，就是这个数组如果
是｛0.1f,0.2f,0.3f｝,假设colors是｛Color.RED,Color.YELLOW,Color.GREEN｝
那么红色的变化范围是0～0.1，黄色的变化0.1f~0.2f,绿色作为最后一个颜色，会自动
填充到1.0f
</code></pre><p>上代码：</p>
<pre><code>RadialGradient gradient = new RadialGradient(200,200,100,new int[]{Color.RED,Color.YELLOW,Color.GREEN},new float[]{0.1f,0.2f,0.3f}, Shader.TileMode.REPEAT);
mPaint.setShader(gradient);
canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);
</code></pre><p><img src="/img/paint_3_shader_7.png" alt=""></p>
<h5 id="SweepGradient"><a href="#SweepGradient" class="headerlink" title="SweepGradient"></a>SweepGradient</h5><pre><code>扫描渐变
SweepGradient(float cx, float cy, int[] colors, float[] positions)
cx：扫描渐变的中心点的X轴的坐标
cy：扫描渐变的中心点的Y轴的坐标
colors：渐变的颜色的范围
position：渐变的颜色数组对应的渐变的位置
</code></pre><p>上代码：</p>
<pre><code>SweepGradient gradient = new SweepGradient(200,200,new int[]{Color.RED,Color.YELLOW,Color.GREEN,Color.CYAN},null);
mPaint.setShader(gradient);
canvas.drawCircle(200,200,100,mPaint);
</code></pre><p><img src="/img/paint_3_shader_8.png" alt=""></p>
<h5 id="ComposeShader"><a href="#ComposeShader" class="headerlink" title="ComposeShader"></a>ComposeShader</h5><pre><code>组合渐变，就是通过Xfermode或者PorterDuff.Mode的方式结合两种Shader，这个类
的重点就在于结合的方式，具体的两个类，请大家参看我的其它文章。
下面我们直接看一下代码

BitmapShader bitmapShader = new BitmapShader(mBitmap, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR);
LinearGradient linearGradient = new LinearGradient(0,200,200,200,new int[]{Color.RED,Color.YELLOW,Color.GREEN},null, Shader.TileMode.CLAMP);
ComposeShader composeShader = new ComposeShader(linearGradient, bitmapShader, PorterDuff.Mode.OVERLAY);
mPaint.setShader(composeShader);
canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint);
</code></pre><p><img src="/img/paint_3_shader_9.png" alt=""></p>
<pre><code>好了，这篇文章就到此结束了。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/PathMeasure的基础用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/PathMeasure的基础用法/" itemprop="url">PathMeasure的基础用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Diposting di</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-15T11:00:21+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/Canvas和Path的基础用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/Canvas和Path的基础用法/" itemprop="url">Canvas和Path的基础用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Diposting di</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-15T11:00:02+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Canvas和Path的基础用法"><a href="#Canvas和Path的基础用法" class="headerlink" title="Canvas和Path的基础用法"></a>Canvas和Path的基础用法</h4><pre><code>   Canvas和Path是自定义View中非常重要的两个的类，Canvas是画布，就是我们在写
自定义View的时候需要绘制的各种东西。我们可以画各种形状，矩形，圆形，椭圆等等。
Path也是个非常强大的类，我们也可以通过Path，画出各种形状，矩形，椭圆等。Path还
涉及到一个比较重要的用法，可以画出贝塞尔曲线，我们可以利用这个画出各种动效。
</code></pre><h5 id="Canvas的基础用法"><a href="#Canvas的基础用法" class="headerlink" title="Canvas的基础用法"></a>Canvas的基础用法</h5><pre><code>    当我们在学习自定义View的时候一定会用到Canvas，可能没有深入的了解过，但是在
绘制的过程中一定会用到，比方说在学习Paint的时候就是会往自定义View上面绘制很多的
东西，这个时候就必须用到Canvas，往Canvas上面画东西。
   Canvas的用法比较重要，重要的是当我们在绘制复杂自定义View的时候往往都需要对
画布做一些变换，平移，缩放，旋转等，知道这些技巧，能够让我们再做自定义View的时候    游刃有余。下面就开始看看画布到底有哪些用法。这里只介绍矩阵的变换，先看看矩阵的平
移变换。

void translate (float dx, float dy);这个方法用来做矩阵的平移
</code></pre><p>上代码：</p>
<pre><code>public class CanvasBaseView extends View {
private Paint mPaint;
private RectF mRectF;

public CanvasBaseView(Context context) {
    this(context,null);
}

public CanvasBaseView(Context context, AttributeSet attrs) {
    this(context, attrs,0);
}

public CanvasBaseView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);

    initPaint();
}

private void initPaint() {
    mPaint = new Paint();
    mPaint.setAntiAlias(true);
    mPaint.setStrokeWidth(5);
    mPaint.setStyle(Paint.Style.STROKE);
    mRectF = new RectF(0,0,300,400);
}


@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.save();
    mPaint.setColor(Color.RED);
    canvas.drawRect(mRectF,mPaint);
    canvas.translate(100,100);
    mPaint.setColor(Color.YELLOW);
    canvas.drawRect(mRectF,mPaint);
    canvas.restore();
    mPaint.setColor(Color.GREEN);
    canvas.drawRect(mRectF,mPaint);
}
}
</code></pre><p>效果图:<br><img src="../img/canvas_path_1.png" alt="translate"></p>
<pre><code>   上面的代码我们一共做了一次画布的平移，画了三个矩形。第一步调用了canvas.save()方法，
   首先我们要知道，在每次调用canvas.drawXXX()方法的时候，其实这个canvas已经
是一个新的画布了，只是这个画布所有的位置信息，都跟上一个画布一样形成我们所看的样
子。并且在绘制完成的时候，所有的画布都会叠在一起，所以我们感受不到这是一个新的画
布，但是我们一旦对画布做了一些变化，这种变化就会立刻明显的体现在我们所绘制的图形
上。
所以分析上面的代码，我们首先调用了canvas。save(),方法，这个方法是把我们当前的
Canvas的相应的信息保存在画布栈中，这个栈保存是每一张画布的信息，只要调用canvas.save()方法，就是把这张画布进栈了。
那么以后当我们继续想应用到这张画布的相关信息的时候就可以把这张画布出栈，这样当我
们再次调用canvas.drawXXX()的时候，这时新建的画布就是相应的出栈的画布的信息
了，结合代码来看的话就是，我们首先保留了最初的画布信息，然后画了一张红色的矩形。
然后对画布进行了平移的操作后，分别向下，向右平移了100px，此时，在画一张黄色的矩
形，最后调用canvas.restore()将相应的画布信息出栈，也就是把画布恢复到最初的状
态，此时再画一个绿色的矩形，我们可以看到绿色的矩形覆盖了红色的矩形。

   void scale(float sx, float sy, float px, float py);这个方法是对画布
进行缩放，sx,sy:分别是画布在X，Y方向的缩放值，px，py是画布缩放所围绕的坐标点，
默认是坐标的原点。
</code></pre><p>上代码：</p>
<pre><code>mPaint.setColor(Color.RED);
canvas.drawRect(mRectF,mPaint);
canvas.scale(1.5f,0.5f);
mPaint.setColor(Color.YELLOW);
canvas.drawRect(mRectF,mPaint);
</code></pre><p>效果图：<br><img src="../img/canvas_path_2.png" alt="scale"></p>
<pre><code>可以看出黄色的矩形，分别在X轴方向放大了1.5倍，在Y轴方向缩小了0.5倍。


void  rotate(float degrees, float px, float py);对画布进行旋转，degree
是画布旋转的角度，旋转的方向是顺时针旋转,px,py是画布旋转时参照的坐标点，简单的
说就是画布绕着px，py这个点顺时针旋转degrees角度
</code></pre><p>上代码：</p>
<pre><code>mPaint.setColor(Color.RED);
canvas.drawRect(mRectF,mPaint);
canvas.rotate(90,300,400);
mPaint.setColor(Color.YELLOW);
canvas.drawRect(mRectF,mPaint);
</code></pre><p>效果图：<br><img src="../img/canvas_path_3.png" alt="rotate"></p>
<pre><code>其实Canvas主要需要知道的就是各种各样的变换。save(),restore()分别表示着进栈和
出栈，弄懂这个是最重要的，然后就是一些Canvas的变换的API的使用，会用这些，那么
Canvas这个类的基础就差不多了。
</code></pre><h5 id="Path的基础用法"><a href="#Path的基础用法" class="headerlink" title="Path的基础用法"></a>Path的基础用法</h5><pre><code>   Path是一个特别重要的类，我们要画的一些几何图形，基本上Path都可以画，并且
Path可以做贝塞尔曲线，有了这些API，实现一些特别的动画效果就有了基础。
    简单介绍一下Path的基础用法，先用Path画个矩形。

public class PathBaseView extends View {
private Paint mPaint;
private Path mPath;
private RectF mRect;
public PathBaseView(Context context) {
    this(context,null);
}

public PathBaseView(Context context, AttributeSet attrs) {
    this(context, attrs,0);
}

public PathBaseView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    initPaint();
    setLayerType(View.LAYER_TYPE_SOFTWARE, null);
}

private void initPaint() {
    mPaint = new Paint();
    mPaint.setAntiAlias(true);
    mPaint.setStyle(Paint.Style.STROKE);
    mPaint.setStrokeWidth(5);
    mPaint.setColor(Color.RED);
    mRect = new RectF(0,0,200,200);
    mPath = new Path();
}


@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    mPath.reset();
    mPath.addRect(mRect, Path.Direction.CCW);
    canvas.drawPath(mPath,mPaint);
}
}
</code></pre><p>效果图：<br><img src="../img/canvas_path_4.png" alt=""></p>
<pre><code>   解释一下上面的代码，setLayerType(View.LAYER_TYPE_SOFTWARE, null);是
关闭硬件加速的。mPath.addRect(mRect, Path.Direction.CCW);这行代码前面是
我们要添加的矩形，后面是我们的路径窄这个矩形上是沿着什么方向添加到Path上的。
Path.Direction.CCW代表是逆时针方向，
Path.Direction.CW代表顺时针方向，方向问题在这里体现的并不是很明显，但是如果我
们要绘制一个有方向的文字，沿着这条Path绘制文字，那么这个时候这个方向的作用就回体
现出来了。mPath.reset()是设置把这个Path上的所有直线和曲线全部清空，就是重置，
这个很好理解，我们每次onDraw()绘制之前，都应该把上次绘制的Path清空了。
</code></pre><p><br></p>
<pre><code>   下面再介绍一下关于画线的几个API，首先是moveTo(float x, float y),就是把
这个Path现在移动到x,y这个点，如果下面要画连接线或者曲线的时候是从这个点开始的，
lineTo(float x, float y);这个表示在这个Path的最后一个坐标点和x，y这个坐标
点之间添加一条线，close();这个表示是否关闭当前的轮廓。
</code></pre><p>上代码：</p>
<pre><code>mPath.reset();
mPath.moveTo(100,100);
mPath.lineTo(300,300);
mPath.moveTo(100,200);
mPath.lineTo(300,400);
mPath.lineTo(200,100);
canvas.drawPath(mPath,mPaint);

上面这段代码比较有代表性的能够解释上面的API，首先是是重置mPath，然后将这条线移动到（100，100）这个坐标点，然后在（300，300）和mPath上的最后一个点（就是（100，100）这个点）连一条线，然后再将mPath的开始点移动到（100，200）这个点，再画一条连接到（300，400）的线，然后在画一条连接mPath上的最后一个点到（200，100）的一条线，现在在mPath上的最后一个点已经变成了（300，400），所以最终mPath就变成了上面图这样的效果。这里面还没用到close(),下面看看，加上了close()方法后，mPath变成了什么样？
</code></pre><p>上代码：</p>
<pre><code>mPath.reset();
mPath.moveTo(100,100);
mPath.lineTo(300,300);
mPath.moveTo(100,200);
mPath.lineTo(300,400);
mPath.lineTo(200,100);
mPath.close();
canvas.drawPath(mPath,mPaint);
</code></pre><p>效果图：<br><img src="../img/canvas_path_6.png" alt=""></p>
<pre><code>   根据上面的图，可以看到，mPath最终被连接起来了，并且连接的并不是mPath的第一
个起始点，而是最后一个起始点，所以close()方法就是把Path的最后一个点和Path上的
最后一个起始点之间连上一条线，构成一个封闭的图形。
</code></pre><h5 id="简单的介绍一下贝塞尔曲线"><a href="#简单的介绍一下贝塞尔曲线" class="headerlink" title="简单的介绍一下贝塞尔曲线"></a>简单的介绍一下贝塞尔曲线</h5><pre><code>    关于贝塞尔曲线的定义，我就不说了，大家自己去百度一下。下面就简单的说一下
Path中简单的连接API，这里的API提供二阶贝塞尔和三阶贝塞尔曲线的连接方式。那么下
面就看一下这些API
quadTo(float x1, float y1, float x2, float y2);其中x1,x2代表在Path的上一个结束点到x2,y2之间连接的一条线的中间的控制点，控制点的坐标就是(x1,x2);
rQuadTo(float dx1, float dy1, float dx2, float dy2);
其中dx1,dy1,dx2,dy2,代表是相对Path的上一个结束点的相对的坐标，加入上一个结束
点的坐标是(dx,dy),那么这个时候控制点的坐标是(dx+dx1,dy+dy1),Path的现在的结
束点就是(dx+dx2,dy+dy2);简单来说这个就是想对上一个坐标点的相对坐标。
</code></pre><p>上代码：</p>
<pre><code>public class PathBaseView extends View {
private Paint mPaint;
private Path mPath;
public PathBaseView(Context context) {
    this(context,null);
}

public PathBaseView(Context context, AttributeSet attrs) {
    this(context, attrs,0);
}

public PathBaseView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    initPaint();
    setLayerType(View.LAYER_TYPE_SOFTWARE, null);
}

private void initPaint() {

    mPaint = new Paint();
    mPaint.setAntiAlias(true);
    mPaint.setStyle(Paint.Style.STROKE);
    mPaint.setStrokeWidth(5);
    mPaint.setColor(Color.RED);
    mRect = new RectF(0,0,200,200);
    mPath = new Path();

}
@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
     mPath.reset();
    //二阶贝赛尔
    //这里是绝对的坐标
    mPath.moveTo(100,100);
    mPath.quadTo(150,50,200,100);
    mPath.quadTo(250,150,300,100);
    //下面是相对坐标
    //mPath.moveTo(100,100);
   //mPath.rQuadTo(50,-50,100,0);
   //mPath.rQuadTo(50,50,100,0);

    canvas.drawPath(mPath,mPaint);
}
｝
</code></pre><p>效果图：<br><img src="../img/canvas_path_7.png" alt="二阶贝塞尔曲线"></p>
<pre><code>可以看出，上面是二阶贝塞尔曲线连接成的类似于正弦曲线。用到了绝对坐标和相对坐标。比较简单。下面看一下用三阶贝塞尔曲线。
</code></pre><p>上代码：</p>
<pre><code>//三阶贝塞尔
mPath.reset();
mPath.moveTo(100,100);
mPath.cubicTo(150,50,250,150,300,100);
//三阶贝塞尔选择相对的函数
//mPath.moveTo(100,100);
//mPath.rCubicTo(50,-50,150,50,200,0);
canvas.drawPath(mPath,mPaint);
</code></pre><p><img src="../img/canvas_path_8.png" alt="三阶贝塞尔曲线"></p>
<pre><code>关于Path和Canvas的基础用法就写到这吧，下面会把这两个结合起来加上属性动画写个自定义View。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/Paint的用法-二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/Paint的用法-二/" itemprop="url">Paint的用法_二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Diposting di</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-15T10:35:42+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Paint的用法-二"><a href="#Paint的用法-二" class="headerlink" title="Paint的用法_二"></a>Paint的用法_二</h4><h5 id="ColorFilter的基础用法"><a href="#ColorFilter的基础用法" class="headerlink" title="ColorFilter的基础用法"></a>ColorFilter的基础用法</h5><pre><code>官方文档关于ColorFilter的介绍是，这个类可以被用于修改被Paint画出的每一个像素
的颜色。并且ColorFilter是一个虚类，不能被直接使用，那么我们就看看它有哪些子类
</code></pre><h6 id="ColorMatrixColorFilter"><a href="#ColorMatrixColorFilter" class="headerlink" title="ColorMatrixColorFilter"></a>ColorMatrixColorFilter</h6><pre><code>我们先来介绍第一个子类 ColorMatrixColorFilter，这个类是通过ColorMatrix来管
理颜色的矩阵变换的，一个像素是有ARGB是个颜色通道的值构成的。显示这些图片，首先要
把这些值加载到内存中，修改像素值，需要一个4*5的ColorMatrix，我们在代码中修改这
个float类型的矩阵，先来个例子，然后再慢慢解释。
</code></pre><p>上代码：</p>
<pre><code>//先画一张没有设置颜色矩阵的原图
mPaint.setColorFilter(null);
canvas.drawBitmap(mBitmap, null, mRect, mPaint);
//色彩增强
ColorMatrix matrix = new ColorMatrix(new float[]{
        1.2f, 0, 0, 0, 0,
        0, 1.2f, 0, 0, 0,
        0, 0, 1.2f, 0, 0,
        0, 0, 0, 1f, 0
});
mPaint.setColorFilter(new ColorMatrixColorFilter(matrix));
canvas.translate(0, 400);
canvas.drawBitmap(mBitmap, null, mRect, mPaint);
</code></pre><p>上个图：<br> <img src="../img/paint_2_colormartix_1.png" alt=""></p>
<pre><code>可从上面的图片对比可以看的出来，下面的图片的色彩比上面的更鲜艳，那么下面的每个像素点的值是怎么通过矩阵的运算得到的呢？这是我们的4*5的矩阵
[ a, b, c, d, e,                [r
  f, g, h, i, j,                  g
  k, l, m, n, o,        *         b
  p, q, r, s, t ]                 a]
那么我们得到的颜色值为
    R’ = a*R + b*G + c*B + d*A + e;
    G’ = f*R + g*G + h*B + i*A + j;
    B’ = k*R + l*G + m*B + n*A + o;
    A’ = p*R + q*G + r*B + s*A + t;
    根据这个公式，我们能够得到上面的矩阵计算，我们是分别把像素的RGB的值，全部乘
    以1.2，所以得到的是色彩的增强。
</code></pre><p>再来个反相变换，反相变换就是把相应的颜色值取反，就是拿255减去现在的值，根据这个结果，我们得到矩阵就是：</p>
<pre><code>//全部取成相反的值，就是拿255减去现在的值
//        ColorMatrix matrix = new ColorMatrix(new float[]{
//                -1f, 0, 0, 0, 255,
//                0, -1f, 0, 0, 255,
//                0, 0, -1f, 0, 255,
//                0, 0, 0, 1f, 0
//        });
</code></pre><p>得到的图片是<br> <img src="../img/paint_2_colormatrix_2.png" alt=""><br> <br><br>再来张黑白照，代码：</p>
<pre><code>ColorMatrix matrix = new ColorMatrix(new float[]{
                0.213f, 0.715f, 0.072f, 0, 0,
                0.213f, 0.715f, 0.072f, 0, 0,
                0.213f, 0.715f, 0.072f, 0, 0,
                0, 0, 0, 1f, 0
        });
</code></pre><p>黑白照：<br> <img src="../img/paint_2_colormatrix_3.png" alt=""><br>来张复古照片：</p>
<pre><code>ColorMatrix matrix = new ColorMatrix(new float[]{
                1 / 2f, 1 / 2f, 1 / 2f, 0, 0,
                1 / 3f, 1 / 3f, 1 / 3f, 0, 0,
                1 / 4f, 1 / 4f, 1 / 4f, 0, 0,
                0, 0, 0, 1f, 0,
        });
</code></pre><p><img src="../img/paint_2_colormatrix_4.png" alt="">           </p>
<p>好了，ColorMatrix的矩阵变换就到这吧，继续看看其他的API。</p>
<pre><code>setScale(float rScale, float gScale, float bScale, float aScale)
rScale:就是我们那个4*5矩阵的变换的R的值
其他的参数都类似，那么设置了这个函数后，其实我们得到的ColorMatrix是
[rScale,0,0,0,0
    0,gScale,0,0,0
    0,0,bScale,0,0
    0,0,0,aScale,0]

setSaturation (float sat);//设置色彩的饱和度
setRotate(int axis, float degrees);//设置色彩的旋转
axis:是围绕那个色彩轴旋转，一共有RGB三个轴，0代表R轴，1代表G轴，2代表B轴
degrees:是围绕这个轴旋转的角度
</code></pre><p>上代码：</p>
<pre><code>ColorMatrix matrix = new ColorMatrix();
matrix.setRotate(0,120);
</code></pre><p><img src="../img/paint_2_colormatrix_5.png" alt="">    </p>
<h5 id="LightingColorFilter"><a href="#LightingColorFilter" class="headerlink" title="LightingColorFilter"></a>LightingColorFilter</h5><pre><code>LightingColorFilter的构造函数是由两个参数构成LightingColorFilter(int mul, int add),
这个类就是提供一种相对简单的方式来操作颜色矩阵的变换其中，mul和add的意义可以有
下面的公式得到：
R&apos; = R * colorMultiply.R + colorAdd.R
G&apos; = G * colorMultiply.G + colorAdd.G
B&apos; = B * colorMultiply.B + colorAdd.B
</code></pre><p>代码如下：</p>
<pre><code>LightingColorFilter colorFilter = new LightingColorFilter(0xffffff,0xff00ff);
mPaint.setColorFilter(colorFilter);
canvas.translate(0, 400);
canvas.drawBitmap(mBitmap, null, mRect, mPaint);
</code></pre><p><img src="../img/paint_2_colormatrix_6.png" alt="">    </p>
<h5 id="PorterDuffColorFilter"><a href="#PorterDuffColorFilter" class="headerlink" title="PorterDuffColorFilter"></a>PorterDuffColorFilter</h5><pre><code>关于PoterDuffColorFilter这个类，要学习这个类，必须要了解他的
</code></pre><p> <img src="../img/paint_2_colormatrix_7.png" alt=""><br> <img src="../img/paint_2_colormatrix_8.png" alt="">           </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">posting</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Tema -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
