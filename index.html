<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="bsdy">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="bsdy">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="bsdy">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>bsdy</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">bsdy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/24/IPC用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/24/IPC用法/" itemprop="url">IPC用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-24T00:51:34+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/24/Service的用法详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/24/Service的用法详解/" itemprop="url">Service的用法详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-24T00:49:43+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/19/根据Shader的自定义View/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/19/根据Shader的自定义View/" itemprop="url">根据Shader的自定义View和放大镜</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-19T16:07:46+08:00">
                2017-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="根据Shader的自定义View和放大镜"><a href="#根据Shader的自定义View和放大镜" class="headerlink" title="根据Shader的自定义View和放大镜"></a>根据Shader的自定义View和放大镜</h4><pre><code>    前期学习了很多关于Paint的基础用法，重要用来做点什么，否则的话很快就会忘记
的，这篇文章就先来实现个简单的Shader的用法，下面还会再来一篇。
    当我们在学习Shader的时候就看到了他的定义，Shader是用来在绘制的过程中把相应
的颜色绘制出来，比如说一张图片有很多的像素值，那么在用这个设置了BitmapShader的
Paint对象绘制任何图形的时候都会在相应的位置绘制出相应的像素。好了，我们理解了这
一点那么接下来的工作就比较简单了。
    先看效果
</code></pre><p><img src="../img/paint_4_shaderView_1.gif" alt=""></p>
<pre><code>    下面就看看该如何实现上面的效果，首先肯定是一张白色的背景图，然后监听我们手指
的出触摸的位置，然后在相应的位置画个圆出来，那么问题就在于如何把这个图片相应的像
素值设置给画笔，这时候就会用到我们的BitmapShader.

public class PaintShaderView extends View {
private Paint mPaint;
private Bitmap mBitmap;
private float dx,dy;
public PaintShaderView(Context context) {
    this(context,null);
}

public PaintShaderView(Context context, AttributeSet attrs) {
    this(context, attrs,0);
}

public PaintShaderView(Context context, AttributeSet attrs, int defStyleAttr) {
mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.girl);
initPaint();
}

 private void initPaint() {
    mPaint = new Paint();
    mPaint.setAntiAlias(true);
    mPaint.setDither(true);
    mPaint.setStrokeWidth(5);
}
  @Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.drawColor(Color.WHITE);
    BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT);
     mPaint.setShader(shader);
     if(dx != 0 &amp;&amp; dy != 0)
    canvas.drawCircle(dx,dy,150,mPaint);
}
@Override
public boolean onTouchEvent(MotionEvent event) {
    switch (event.getAction()){
        case MotionEvent.ACTION_DOWN:
            dx = 0;
            dy = 0;
            invalidate();
            return  true;
        case MotionEvent.ACTION_MOVE:
            dx = event.getX();
            dy = event.getY();
            invalidate();
            return true;
        case MotionEvent.ACTION_UP:
            dx = 0;
            dy = 0;
            break;
    }
    invalidate();
    return super.onTouchEvent(event);
}
}
</code></pre><h5 id="根据Shader制作放大器自定义View"><a href="#根据Shader制作放大器自定义View" class="headerlink" title="根据Shader制作放大器自定义View"></a>根据Shader制作放大器自定义View</h5>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/Paint的Gradient的用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/Paint的Gradient的用法/" itemprop="url">Paint的Gradient的用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-15T13:53:17+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Paint的Gradient的用法"><a href="#Paint的Gradient的用法" class="headerlink" title="Paint的Gradient的用法"></a>Paint的Gradient的用法</h4><h5 id="shader的基本介绍"><a href="#shader的基本介绍" class="headerlink" title="shader的基本介绍"></a>shader的基本介绍</h5><pre><code>shader是一个在绘制的过程中能够水平的平分颜色的一个基类，通过Shader的子类的实现
来给Paint设置Shader，设置过之后，绘制任何对象时都会带着这个Shader的颜色。
</code></pre><h5 id="BitmapShader"><a href="#BitmapShader" class="headerlink" title="BitmapShader"></a>BitmapShader</h5><pre><code>这是一个非常有用的类，下面我会介绍一些这个类的基本的用法，中间会包括一些
Shader的基本用法，都在这个介绍类的里面了，下面可 is hi，我们首先看看这个类的
构造函数，然后直接使用，看看会有什么奇妙的东西发生。这个Shader作为纹理被用来
绘制Bitmap看看构造方法.
</code></pre><ul>
<li><p>REPEAT</p>
<pre><code>mRect = new RectF(0,0,200,200);
mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.girl);
BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.REPEAT, Shader.TileMode.REPEAT);
mPaint.setShader(shader);
canvas.drawRect(0,0,getWidth(),getHeight() ,mPaint);
</code></pre><p><img src="/img/paint_3_shader_1.png" alt=""><br><br></p>
<pre><code>根据图片，我们看到绘制出来的不是单独的的一张照片，而是单张照片的重复，这就
涉及到在上面的代码中，我们没有提到的Shader.TileMode这个内部类。这个类内
部有三个值，分别是CLAMP，REPEAT，MIRROR。其中CLAMP代表的是重复绘制这个
Shader的边缘的像素，当超出这个Shader的原始界限的时候，REPEAT就是重复，
MIRROR就是镜像。这个三个值的不用多说，看看代码的效果就明白了。
</code></pre><p>上代码：</p>
</li>
<li><p>CLAMP</p>
<pre><code>mRect = new RectF(0,0,200,200);
mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.girl);
BitmapShader shader = new BitmapShader(mBitmap,Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
mPaint.setShader(shader);
canvas.drawRect(0,0,getWidth(),getHeight() ,mPaint);
</code></pre></li>
</ul>
<p><img src="/img/paint_3_shader_2.png" alt="这是CLAMP的效果"></p>
<ul>
<li><p>MIRROR</p>
<pre><code>mRect = new RectF(0,0,200,200);
mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.girl);
BitmapShader shader = new BitmapShader(mBitmap,Shader.TileMode. MIRROR, Shader.TileMode. MIRROR);
mPaint.setShader(shader);
canvas.drawRect(0,0,getWidth(),getHeight() ,mPaint);
</code></pre></li>
</ul>
<p><img src="/img/paint_3_shader_3.png" alt="这是CLAMP的效果"></p>
<pre><code>解释一下构造方法：
BitmapShader(Bitmap bitmap, Shader.TileMode tileX, Shader.TileMode tileY)
bitmap：就是你给这个BitmapShader设置的图片
tileX：就是当这个Shader超出这个图像的原始的边界的时候，给这个Shader设置的X轴方向的拉伸规则
tileY：同理上面的tileX
</code></pre><p><br></p>
<h5 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h5><pre><code>下面再来一个比较有点意思的类，Matrix，矩阵。Matrix是一个为了转换坐标持有一个
3*3的矩阵的一个类。因为这里是在Shader的知识里面，我们就介绍一点基本知识就行，
Matrix的构造方法没什么要看的，大家一看就明白，分别是Matrix()，Matrix(Matrix src)
然后看看他的setScale(float sx, float sy)方法，sx，sy分别表示X，Y轴的缩放比例。
我们在Shader的setLocalMatrix (Matrix localM)里面会用到矩阵的变换，那么
</code></pre><p>上代码：</p>
<pre><code>BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR);
Matrix matrix = new Matrix();
matrix.setScale(1.5f,0.5f);
shader.setLocalMatrix(matrix);
mPaint.setShader(shader);        
canvas.drawRect(0,0,getWidth(),getHeight() ,mPaint);
</code></pre><p><img src="/img/paint_3_shader_4.png" alt=""></p>
<pre><code>从上面的图可以看出，X轴放大了1.5倍，Y轴缩小了0.5倍

下面我们接着看看Matrix的其它方法setTranslate(float dx, float dy)，设置    矩阵沿着X，Y轴分别平移dx，dy。dx为正，图片就右移，反之左移，dy为正图片下移，
反之上移
</code></pre><p>上代码：</p>
<pre><code>BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR);
Matrix matrix = new Matrix();
matrix.setTranslate(50,50);
shader.setLocalMatrix(matrix);
mPaint.setShader(shader);        
canvas.drawRect(0,0,getWidth(),getHeight() ,mPaint);
</code></pre><p><img src="/img/paint_3_shader_5.png" alt=""></p>
<pre><code>setRotate(float degrees),设置矩阵围绕着原点旋转degrees度。
setSkew(float kx, float ky)，设置矩阵的X，Y方向的倾斜度。
这两个方法，我就不运行了，大家自己试一下。
好了，到这里我就把BitmapShader介绍的差不多了，也介绍了Shader的setLocalMatrix(matrix)方法
顺便说了一点Matrix类，下面回归主题，看看其它的Shader的子类。
</code></pre><h5 id="LinearGradient"><a href="#LinearGradient" class="headerlink" title="LinearGradient"></a>LinearGradient</h5><pre><code>线性渐变，比较简单，把构造方法弄明白就行了
LinearGradient(float x0, float y0, float x1, float y1, int[] colors, float[] positions, Shader.TileMode tile)
x0,y0,x1,y1 : 代表这个颜色变化的起点位置和终点位置
colors: 是颜色的变化的范围
positions ：是每个颜色的在总变化的范围所占的所有的值加起来等于1 。类似于权重,可以为null，为null的话就是每个颜色所占的比重相同
tile：是这个图形的拉伸规则，参看BitmapShader
</code></pre><p>上代码：</p>
<pre><code>LinearGradient gradient = new LinearGradient(0,200,200,200,new int[]{Color.RED,Color.YELLOW,Color.GREEN},null, Shader.TileMode.CLAMP);
mPaint.setShader(gradient);
canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);
</code></pre><p><img src="/img/paint_3_shader_6.png" alt=""></p>
<h5 id="RadialGradient"><a href="#RadialGradient" class="headerlink" title="RadialGradient"></a>RadialGradient</h5><pre><code>径向渐变，直接看
RadialGradient(float centerX, float centerY, float radius, int[] colors, float[] stops, Shader.TileMode tileMode)
centerX，centerY，radius，是画圆的三个要素，中心坐标加半径。
colors：是颜色的变化范围
stops：这个数组里面的数对应的是颜色的变化范围到什么位置停止，就是这个数组如果
是｛0.1f,0.2f,0.3f｝,假设colors是｛Color.RED,Color.YELLOW,Color.GREEN｝
那么红色的变化范围是0～0.1，黄色的变化0.1f~0.2f,绿色作为最后一个颜色，会自动
填充到1.0f
</code></pre><p>上代码：</p>
<pre><code>RadialGradient gradient = new RadialGradient(200,200,100,new int[]{Color.RED,Color.YELLOW,Color.GREEN},new float[]{0.1f,0.2f,0.3f}, Shader.TileMode.REPEAT);
mPaint.setShader(gradient);
canvas.drawRect(0,0,getWidth(),getHeight(),mPaint);
</code></pre><p><img src="/img/paint_3_shader_7.png" alt=""></p>
<h5 id="SweepGradient"><a href="#SweepGradient" class="headerlink" title="SweepGradient"></a>SweepGradient</h5><pre><code>扫描渐变
SweepGradient(float cx, float cy, int[] colors, float[] positions)
cx：扫描渐变的中心点的X轴的坐标
cy：扫描渐变的中心点的Y轴的坐标
colors：渐变的颜色的范围
position：渐变的颜色数组对应的渐变的位置
</code></pre><p>上代码：</p>
<pre><code>SweepGradient gradient = new SweepGradient(200,200,new int[]{Color.RED,Color.YELLOW,Color.GREEN,Color.CYAN},null);
mPaint.setShader(gradient);
canvas.drawCircle(200,200,100,mPaint);
</code></pre><p><img src="/img/paint_3_shader_8.png" alt=""></p>
<h5 id="ComposeShader"><a href="#ComposeShader" class="headerlink" title="ComposeShader"></a>ComposeShader</h5><pre><code>组合渐变，就是通过Xfermode或者PorterDuff.Mode的方式结合两种Shader，这个类
的重点就在于结合的方式，具体的两个类，请大家参看我的其它文章。
下面我们直接看一下代码

BitmapShader bitmapShader = new BitmapShader(mBitmap, Shader.TileMode.MIRROR, Shader.TileMode.MIRROR);
LinearGradient linearGradient = new LinearGradient(0,200,200,200,new int[]{Color.RED,Color.YELLOW,Color.GREEN},null, Shader.TileMode.CLAMP);
ComposeShader composeShader = new ComposeShader(linearGradient, bitmapShader, PorterDuff.Mode.OVERLAY);
mPaint.setShader(composeShader);
canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint);
</code></pre><p><img src="/img/paint_3_shader_9.png" alt=""></p>
<pre><code>好了，这篇文章就到此结束了。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/PathMeasure的基础用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/PathMeasure的基础用法/" itemprop="url">PathMeasure的基础用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-15T11:00:21+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/Canvas和Path的基础用法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/Canvas和Path的基础用法/" itemprop="url">Canvas和Path的基础用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-15T11:00:02+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Canvas和Path的基础用法"><a href="#Canvas和Path的基础用法" class="headerlink" title="Canvas和Path的基础用法"></a>Canvas和Path的基础用法</h4><pre><code>   Canvas和Path是自定义View中非常重要的两个的类，Canvas是画布，就是我们在写
自定义View的时候需要绘制的各种东西。我们可以画各种形状，矩形，圆形，椭圆等等。
Path也是个非常强大的类，我们也可以通过Path，画出各种形状，矩形，椭圆等。Path还
涉及到一个比较重要的用法，可以画出贝塞尔曲线，我们可以利用这个画出各种动效。
</code></pre><h5 id="Canvas的基础用法"><a href="#Canvas的基础用法" class="headerlink" title="Canvas的基础用法"></a>Canvas的基础用法</h5><pre><code>    当我们在学习自定义View的时候一定会用到Canvas，可能没有深入的了解过，但是在
绘制的过程中一定会用到，比方说在学习Paint的时候就是会往自定义View上面绘制很多的
东西，这个时候就必须用到Canvas，往Canvas上面画东西。
   Canvas的用法比较重要，重要的是当我们在绘制复杂自定义View的时候往往都需要对
画布做一些变换，平移，缩放，旋转等，知道这些技巧，能够让我们再做自定义View的时候    游刃有余。下面就开始看看画布到底有哪些用法。这里只介绍矩阵的变换，先看看矩阵的平
移变换。

void translate (float dx, float dy);这个方法用来做矩阵的平移
</code></pre><p>上代码：</p>
<pre><code>public class CanvasBaseView extends View {
private Paint mPaint;
private RectF mRectF;

public CanvasBaseView(Context context) {
    this(context,null);
}

public CanvasBaseView(Context context, AttributeSet attrs) {
    this(context, attrs,0);
}

public CanvasBaseView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);

    initPaint();
}

private void initPaint() {
    mPaint = new Paint();
    mPaint.setAntiAlias(true);
    mPaint.setStrokeWidth(5);
    mPaint.setStyle(Paint.Style.STROKE);
    mRectF = new RectF(0,0,300,400);
}


@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.save();
    mPaint.setColor(Color.RED);
    canvas.drawRect(mRectF,mPaint);
    canvas.translate(100,100);
    mPaint.setColor(Color.YELLOW);
    canvas.drawRect(mRectF,mPaint);
    canvas.restore();
    mPaint.setColor(Color.GREEN);
    canvas.drawRect(mRectF,mPaint);
}
}
</code></pre><p>效果图:<br><img src="../img/canvas_path_1.png" alt="translate"></p>
<pre><code>   上面的代码我们一共做了一次画布的平移，画了三个矩形。第一步调用了canvas.save()方法，
   首先我们要知道，在每次调用canvas.drawXXX()方法的时候，其实这个canvas已经
是一个新的画布了，只是这个画布所有的位置信息，都跟上一个画布一样形成我们所看的样
子。并且在绘制完成的时候，所有的画布都会叠在一起，所以我们感受不到这是一个新的画
布，但是我们一旦对画布做了一些变化，这种变化就会立刻明显的体现在我们所绘制的图形
上。
所以分析上面的代码，我们首先调用了canvas。save(),方法，这个方法是把我们当前的
Canvas的相应的信息保存在画布栈中，这个栈保存是每一张画布的信息，只要调用canvas.save()方法，就是把这张画布进栈了。
那么以后当我们继续想应用到这张画布的相关信息的时候就可以把这张画布出栈，这样当我
们再次调用canvas.drawXXX()的时候，这时新建的画布就是相应的出栈的画布的信息
了，结合代码来看的话就是，我们首先保留了最初的画布信息，然后画了一张红色的矩形。
然后对画布进行了平移的操作后，分别向下，向右平移了100px，此时，在画一张黄色的矩
形，最后调用canvas.restore()将相应的画布信息出栈，也就是把画布恢复到最初的状
态，此时再画一个绿色的矩形，我们可以看到绿色的矩形覆盖了红色的矩形。

   void scale(float sx, float sy, float px, float py);这个方法是对画布
进行缩放，sx,sy:分别是画布在X，Y方向的缩放值，px，py是画布缩放所围绕的坐标点，
默认是坐标的原点。
</code></pre><p>上代码：</p>
<pre><code>mPaint.setColor(Color.RED);
canvas.drawRect(mRectF,mPaint);
canvas.scale(1.5f,0.5f);
mPaint.setColor(Color.YELLOW);
canvas.drawRect(mRectF,mPaint);
</code></pre><p>效果图：<br><img src="../img/canvas_path_2.png" alt="scale"></p>
<pre><code>可以看出黄色的矩形，分别在X轴方向放大了1.5倍，在Y轴方向缩小了0.5倍。


void  rotate(float degrees, float px, float py);对画布进行旋转，degree
是画布旋转的角度，旋转的方向是顺时针旋转,px,py是画布旋转时参照的坐标点，简单的
说就是画布绕着px，py这个点顺时针旋转degrees角度
</code></pre><p>上代码：</p>
<pre><code>mPaint.setColor(Color.RED);
canvas.drawRect(mRectF,mPaint);
canvas.rotate(90,300,400);
mPaint.setColor(Color.YELLOW);
canvas.drawRect(mRectF,mPaint);
</code></pre><p>效果图：<br><img src="../img/canvas_path_3.png" alt="rotate"></p>
<pre><code>其实Canvas主要需要知道的就是各种各样的变换。save(),restore()分别表示着进栈和
出栈，弄懂这个是最重要的，然后就是一些Canvas的变换的API的使用，会用这些，那么
Canvas这个类的基础就差不多了。
</code></pre><h5 id="Path的基础用法"><a href="#Path的基础用法" class="headerlink" title="Path的基础用法"></a>Path的基础用法</h5><pre><code>   Path是一个特别重要的类，我们要画的一些几何图形，基本上Path都可以画，并且
Path可以做贝塞尔曲线，有了这些API，实现一些特别的动画效果就有了基础。
    简单介绍一下Path的基础用法，先用Path画个矩形。

public class PathBaseView extends View {
private Paint mPaint;
private Path mPath;
private RectF mRect;
public PathBaseView(Context context) {
    this(context,null);
}

public PathBaseView(Context context, AttributeSet attrs) {
    this(context, attrs,0);
}

public PathBaseView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    initPaint();
    setLayerType(View.LAYER_TYPE_SOFTWARE, null);
}

private void initPaint() {
    mPaint = new Paint();
    mPaint.setAntiAlias(true);
    mPaint.setStyle(Paint.Style.STROKE);
    mPaint.setStrokeWidth(5);
    mPaint.setColor(Color.RED);
    mRect = new RectF(0,0,200,200);
    mPath = new Path();
}


@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    mPath.reset();
    mPath.addRect(mRect, Path.Direction.CCW);
    canvas.drawPath(mPath,mPaint);
}
}
</code></pre><p>效果图：<br><img src="../img/canvas_path_4.png" alt=""></p>
<pre><code>   解释一下上面的代码，setLayerType(View.LAYER_TYPE_SOFTWARE, null);是
关闭硬件加速的。mPath.addRect(mRect, Path.Direction.CCW);这行代码前面是
我们要添加的矩形，后面是我们的路径窄这个矩形上是沿着什么方向添加到Path上的。
Path.Direction.CCW代表是逆时针方向，
Path.Direction.CW代表顺时针方向，方向问题在这里体现的并不是很明显，但是如果我
们要绘制一个有方向的文字，沿着这条Path绘制文字，那么这个时候这个方向的作用就回体
现出来了。mPath.reset()是设置把这个Path上的所有直线和曲线全部清空，就是重置，
这个很好理解，我们每次onDraw()绘制之前，都应该把上次绘制的Path清空了。
</code></pre><p><br></p>
<pre><code>   下面再介绍一下关于画线的几个API，首先是moveTo(float x, float y),就是把
这个Path现在移动到x,y这个点，如果下面要画连接线或者曲线的时候是从这个点开始的，
lineTo(float x, float y);这个表示在这个Path的最后一个坐标点和x，y这个坐标
点之间添加一条线，close();这个表示是否关闭当前的轮廓。
</code></pre><p>上代码：</p>
<pre><code>mPath.reset();
mPath.moveTo(100,100);
mPath.lineTo(300,300);
mPath.moveTo(100,200);
mPath.lineTo(300,400);
mPath.lineTo(200,100);
canvas.drawPath(mPath,mPaint);

上面这段代码比较有代表性的能够解释上面的API，首先是是重置mPath，然后将这条线移动到（100，100）这个坐标点，然后在（300，300）和mPath上的最后一个点（就是（100，100）这个点）连一条线，然后再将mPath的开始点移动到（100，200）这个点，再画一条连接到（300，400）的线，然后在画一条连接mPath上的最后一个点到（200，100）的一条线，现在在mPath上的最后一个点已经变成了（300，400），所以最终mPath就变成了上面图这样的效果。这里面还没用到close(),下面看看，加上了close()方法后，mPath变成了什么样？
</code></pre><p>上代码：</p>
<pre><code>mPath.reset();
mPath.moveTo(100,100);
mPath.lineTo(300,300);
mPath.moveTo(100,200);
mPath.lineTo(300,400);
mPath.lineTo(200,100);
mPath.close();
canvas.drawPath(mPath,mPaint);
</code></pre><p>效果图：<br><img src="../img/canvas_path_6.png" alt=""></p>
<pre><code>   根据上面的图，可以看到，mPath最终被连接起来了，并且连接的并不是mPath的第一
个起始点，而是最后一个起始点，所以close()方法就是把Path的最后一个点和Path上的
最后一个起始点之间连上一条线，构成一个封闭的图形。
</code></pre><h5 id="简单的介绍一下贝塞尔曲线"><a href="#简单的介绍一下贝塞尔曲线" class="headerlink" title="简单的介绍一下贝塞尔曲线"></a>简单的介绍一下贝塞尔曲线</h5><pre><code>    关于贝塞尔曲线的定义，我就不说了，大家自己去百度一下。下面就简单的说一下
Path中简单的连接API，这里的API提供二阶贝塞尔和三阶贝塞尔曲线的连接方式。那么下
面就看一下这些API
quadTo(float x1, float y1, float x2, float y2);其中x1,x2代表在Path的上一个结束点到x2,y2之间连接的一条线的中间的控制点，控制点的坐标就是(x1,x2);
rQuadTo(float dx1, float dy1, float dx2, float dy2);
其中dx1,dy1,dx2,dy2,代表是相对Path的上一个结束点的相对的坐标，加入上一个结束
点的坐标是(dx,dy),那么这个时候控制点的坐标是(dx+dx1,dy+dy1),Path的现在的结
束点就是(dx+dx2,dy+dy2);简单来说这个就是想对上一个坐标点的相对坐标。
</code></pre><p>上代码：</p>
<pre><code>public class PathBaseView extends View {
private Paint mPaint;
private Path mPath;
public PathBaseView(Context context) {
    this(context,null);
}

public PathBaseView(Context context, AttributeSet attrs) {
    this(context, attrs,0);
}

public PathBaseView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    initPaint();
    setLayerType(View.LAYER_TYPE_SOFTWARE, null);
}

private void initPaint() {

    mPaint = new Paint();
    mPaint.setAntiAlias(true);
    mPaint.setStyle(Paint.Style.STROKE);
    mPaint.setStrokeWidth(5);
    mPaint.setColor(Color.RED);
    mRect = new RectF(0,0,200,200);
    mPath = new Path();

}
@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
     mPath.reset();
    //二阶贝赛尔
    //这里是绝对的坐标
    mPath.moveTo(100,100);
    mPath.quadTo(150,50,200,100);
    mPath.quadTo(250,150,300,100);
    //下面是相对坐标
    //mPath.moveTo(100,100);
   //mPath.rQuadTo(50,-50,100,0);
   //mPath.rQuadTo(50,50,100,0);

    canvas.drawPath(mPath,mPaint);
}
｝
</code></pre><p>效果图：<br><img src="../img/canvas_path_7.png" alt="二阶贝塞尔曲线"></p>
<pre><code>可以看出，上面是二阶贝塞尔曲线连接成的类似于正弦曲线。用到了绝对坐标和相对坐标。比较简单。下面看一下用三阶贝塞尔曲线。
</code></pre><p>上代码：</p>
<pre><code>//三阶贝塞尔
mPath.reset();
mPath.moveTo(100,100);
mPath.cubicTo(150,50,250,150,300,100);
//三阶贝塞尔选择相对的函数
//mPath.moveTo(100,100);
//mPath.rCubicTo(50,-50,150,50,200,0);
canvas.drawPath(mPath,mPaint);
</code></pre><p><img src="../img/canvas_path_8.png" alt="三阶贝塞尔曲线"></p>
<pre><code>关于Path和Canvas的基础用法就写到这吧，下面会把这两个结合起来加上属性动画写个自定义View。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/15/Paint的用法-二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="bsdy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/15/Paint的用法-二/" itemprop="url">Paint的用法_二</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-15T10:35:42+08:00">
                2017-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Paint的用法-二"><a href="#Paint的用法-二" class="headerlink" title="Paint的用法_二"></a>Paint的用法_二</h4><h5 id="ColorFilter的基础用法"><a href="#ColorFilter的基础用法" class="headerlink" title="ColorFilter的基础用法"></a>ColorFilter的基础用法</h5><pre><code>官方文档关于ColorFilter的介绍是，这个类可以被用于修改被Paint画出的每一个像素
的颜色。并且ColorFilter是一个虚类，不能被直接使用，那么我们就看看它有哪些子类
</code></pre><h6 id="ColorMatrixColorFilter"><a href="#ColorMatrixColorFilter" class="headerlink" title="ColorMatrixColorFilter"></a>ColorMatrixColorFilter</h6><pre><code>我们先来介绍第一个子类 ColorMatrixColorFilter，这个类是通过ColorMatrix来管
理颜色的矩阵变换的，一个像素是有ARGB是个颜色通道的值构成的。显示这些图片，首先要
把这些值加载到内存中，修改像素值，需要一个4*5的ColorMatrix，我们在代码中修改这
个float类型的矩阵，先来个例子，然后再慢慢解释。
</code></pre><p>上代码：</p>
<pre><code>//先画一张没有设置颜色矩阵的原图
mPaint.setColorFilter(null);
canvas.drawBitmap(mBitmap, null, mRect, mPaint);
//色彩增强
ColorMatrix matrix = new ColorMatrix(new float[]{
        1.2f, 0, 0, 0, 0,
        0, 1.2f, 0, 0, 0,
        0, 0, 1.2f, 0, 0,
        0, 0, 0, 1f, 0
});
mPaint.setColorFilter(new ColorMatrixColorFilter(matrix));
canvas.translate(0, 400);
canvas.drawBitmap(mBitmap, null, mRect, mPaint);
</code></pre><p>上个图：<br> <img src="../img/paint_2_colormartix_1.png" alt=""></p>
<pre><code>可从上面的图片对比可以看的出来，下面的图片的色彩比上面的更鲜艳，那么下面的每个像素点的值是怎么通过矩阵的运算得到的呢？这是我们的4*5的矩阵
[ a, b, c, d, e,                [r
  f, g, h, i, j,                  g
  k, l, m, n, o,        *         b
  p, q, r, s, t ]                 a]
那么我们得到的颜色值为
    R’ = a*R + b*G + c*B + d*A + e;
    G’ = f*R + g*G + h*B + i*A + j;
    B’ = k*R + l*G + m*B + n*A + o;
    A’ = p*R + q*G + r*B + s*A + t;
    根据这个公式，我们能够得到上面的矩阵计算，我们是分别把像素的RGB的值，全部乘
    以1.2，所以得到的是色彩的增强。
</code></pre><p>再来个反相变换，反相变换就是把相应的颜色值取反，就是拿255减去现在的值，根据这个结果，我们得到矩阵就是：</p>
<pre><code>//全部取成相反的值，就是拿255减去现在的值
//        ColorMatrix matrix = new ColorMatrix(new float[]{
//                -1f, 0, 0, 0, 255,
//                0, -1f, 0, 0, 255,
//                0, 0, -1f, 0, 255,
//                0, 0, 0, 1f, 0
//        });
</code></pre><p>得到的图片是<br> <img src="../img/paint_2_colormatrix_2.png" alt=""><br> <br><br>再来张黑白照，代码：</p>
<pre><code>ColorMatrix matrix = new ColorMatrix(new float[]{
                0.213f, 0.715f, 0.072f, 0, 0,
                0.213f, 0.715f, 0.072f, 0, 0,
                0.213f, 0.715f, 0.072f, 0, 0,
                0, 0, 0, 1f, 0
        });
</code></pre><p>黑白照：<br> <img src="../img/paint_2_colormatrix_3.png" alt=""><br>来张复古照片：</p>
<pre><code>ColorMatrix matrix = new ColorMatrix(new float[]{
                1 / 2f, 1 / 2f, 1 / 2f, 0, 0,
                1 / 3f, 1 / 3f, 1 / 3f, 0, 0,
                1 / 4f, 1 / 4f, 1 / 4f, 0, 0,
                0, 0, 0, 1f, 0,
        });
</code></pre><p><img src="../img/paint_2_colormatrix_4.png" alt="">           </p>
<p>好了，ColorMatrix的矩阵变换就到这吧，继续看看其他的API。</p>
<pre><code>setScale(float rScale, float gScale, float bScale, float aScale)
rScale:就是我们那个4*5矩阵的变换的R的值
其他的参数都类似，那么设置了这个函数后，其实我们得到的ColorMatrix是
[rScale,0,0,0,0
    0,gScale,0,0,0
    0,0,bScale,0,0
    0,0,0,aScale,0]

setSaturation (float sat);//设置色彩的饱和度
setRotate(int axis, float degrees);//设置色彩的旋转
axis:是围绕那个色彩轴旋转，一共有RGB三个轴，0代表R轴，1代表G轴，2代表B轴
degrees:是围绕这个轴旋转的角度
</code></pre><p>上代码：</p>
<pre><code>ColorMatrix matrix = new ColorMatrix();
matrix.setRotate(0,120);
</code></pre><p><img src="../img/paint_2_colormatrix_5.png" alt="">    </p>
<h5 id="LightingColorFilter"><a href="#LightingColorFilter" class="headerlink" title="LightingColorFilter"></a>LightingColorFilter</h5><pre><code>LightingColorFilter的构造函数是由两个参数构成LightingColorFilter(int mul, int add),
这个类就是提供一种相对简单的方式来操作颜色矩阵的变换其中，mul和add的意义可以有
下面的公式得到：
R&apos; = R * colorMultiply.R + colorAdd.R
G&apos; = G * colorMultiply.G + colorAdd.G
B&apos; = B * colorMultiply.B + colorAdd.B
</code></pre><p>代码如下：</p>
<pre><code>LightingColorFilter colorFilter = new LightingColorFilter(0xffffff,0xff00ff);
mPaint.setColorFilter(colorFilter);
canvas.translate(0, 400);
canvas.drawBitmap(mBitmap, null, mRect, mPaint);
</code></pre><p><img src="../img/paint_2_colormatrix_6.png" alt="">    </p>
<h5 id="PorterDuffColorFilter"><a href="#PorterDuffColorFilter" class="headerlink" title="PorterDuffColorFilter"></a>PorterDuffColorFilter</h5><pre><code>关于PoterDuffColorFilter这个类，要学习这个类，必须要了解他的
</code></pre><p> <img src="../img/paint_2_colormatrix_7.png" alt=""><br> <img src="../img/paint_2_colormatrix_8.png" alt="">           </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
